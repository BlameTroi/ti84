<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Z80 Assembly</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="Stylesheet" href="normal.css">
</head>
<body>
<h1>Z80 Assembly - Instructions: Hardware Related</h1>
<h2>Handling interrupts</h2>
<p>These are the instructions that deal with controlling the interrupts.</p>
<h3>DI</h3>
<p>There are no operands. When <code>di</code> is executed, the (maskable) interrupts are disabled. The flags are preserved.</p>
<h3>EI</h3>
<p>There are no operands. When <code>ei</code> is executed, the (maskable) interrupts are enabled. The flags are preserved.</p>
<h3>RETI</h3>
<p>This instruction returns from the interrupt routine. From the programmer&rsquo;s point of view it is no more than a simple <code>ret</code>, but it has to be used to properly handle the interrupt. Note that you cannot use conditions with <code>reti</code>. The flags are not affected.</p>
<h3>RETN</h3>
<p>Basically the same as <code>reti</code>, but this one is used to return from the nonmaskable interrupt (NMI).</p>
<h3>IM</h3>
<p>Syntax: <code>im mode</code> where mode is 0, 1 or 2</p>
<p>Setting the interrupt mode. The flags are not affected. Mode 0 means that only external devices generate interrupts, and the devices send instructions (mostly <code>rst</code>) to the CPU to execute. (this is not used in the TI calculators). When mode 1 is active, interrupts are generated by the internal circuitry of the processor, and each time this occurs, <code>rst $38</code> is executed. The frequency of these interrupts is 200 per second on a ZX Spectrum, but it depends on the state of the batteries in the case of TI calculators (probably varies between 100 and 150). Mode 2 causes the user interrupt to be executed instead of <code>rst $38</code>. You can read more about this process in the Interrupts section.</p>
<h3>RST</h3>
<p>Syntax: <code>rst address</code> where address is $00, $08, $10, $18, $20, $28, $30 or $38</p>
<p>The long name of this instruction is Restart; it is basically a <code>call</code> to the given address. The action taken by the <code>rst</code>&rsquo;s depends on what kind of hardware you have. On the TI calculators they are equivalent to some of the most important ROM calls. Another example from the Spectrum: <code>rst $28</code> activates the built-in floating point calculator. The <code>rst</code> instruction does not affect the flags either.</p>
<h2><a name="ports"></a>Handling ports</h2>
<p>With these instructions, the CPU can communicate with other pieces of hardware present in the computer. The functions of the ports again depend on the hardware itself.</p>
<h3>IN</h3>
<p>Syntax: <code>in a,(n)</code> (n is a byte) or <code>in reg8,(c)</code> (where reg8 is <tt>A</tt>, <tt>B</tt>, <tt>C</tt>, <tt>D</tt>, <tt>E</tt>, <tt>H</tt> or <tt>L</tt>)</p>
<p>Reading from the port marked by the second operand, and storing the result into the first operand. The <kbd>carry</kbd> is preserved, <kbd>N</kbd> is cleared, <kbd>P/V</kbd> is <i>parity</i> and the other flags are affected by definition. There exists an undocumented version as well: <code>in (c)</code> (or <code>in f,(c)</code> depending on what you compile your programs with), which does not store the result anywhere, but still alters the flags.</p>
<h3>OUT</h3>
<p>Syntax: <code>out (n),a</code> (n is a byte) or <code>out (c),reg8</code> (where reg8 is <tt>A</tt>, <tt>B</tt>, <tt>C</tt>, <tt>D</tt>, <tt>E</tt>, <tt>H</tt> or <tt>L</tt>)</p>
<p>Writing the value of the second operand to the port given in the first operand. The flags are preserved. Similarly to <code>in</code> there is an undocumented combination: <code>out (c),0</code> can be used, too.</p>
<h3>INI</h3>
<p>There are no operands. Reads the (C) port and writes the result to <tt>(HL)</tt>, then increments <tt>HL</tt> and decrements <tt>B</tt> (not <tt>BC</tt>!). The <kbd>carry</kbd> is preserved, the <kbd>N</kbd> flag is reset, while <kbd>S</kbd>, <kbd>H</kbd> and <kbd>P/V</kbd> are undefined. <kbd>Z</kbd> is set if <tt>B</tt> becomes zero after decrementing, otherwise it is reset.</p>
<h3>IND</h3>
<p>The same as <code>ini</code> with the minor difference that <tt>HL</tt> is <i>decremented</i>.</p>
<h3>INIR</h3>
<p>This is <code>ini</code> repeated until <tt>B</tt> becomes zero. Therefore the <kbd>Z</kbd> flag is always set on leaving the instruction.</p>
<h3>INDR</h3>
<p>The same as <code>inir</code>, but the memory is naturally filled backwards.</p>
<h3>OUTI</h3>
<p>There are no operands. Reads the byte at <tt>(HL)</tt> and outputs it to the (C) port, then increments <tt>HL</tt> and decrements <tt>B</tt>. The <kbd>carry</kbd> is preserved, the <kbd>N</kbd> flag is reset, while <kbd>S</kbd>, <kbd>H</kbd> and <kbd>P/V</kbd> are undefined. <kbd>Z</kbd> is set if <tt>B</tt> becomes zero after decrementing, otherwise it is reset.</p>
<h3>OUTD</h3>
<p>The same as <code>outi</code> with the minor difference that <tt>HL</tt> is <i>decremented</i>.</p>
<h3>OTIR</h3>
<p>This is <code>outi</code> repeated until <tt>B</tt> becomes zero. Therefore the <kbd>Z</kbd> flag is always set on leaving the instruction.</p>
<h3>OTDR</h3>
<p>The same as <code>otir</code>, but the memory is naturally filled backwards.</p>
<h2><a name="susp"></a>Suspending the execution</h2>
<p>These are the two instructions that do almost nothing. Neither of them needs any operands, and they do not alter the flags either.</p>
<h3>NOP</h3>
<p>This instruction waits for an elementary amount of time: 4 clock cycles, and does nothing else.</p>
<h3>HALT</h3>
<p>The execution of instructions is suspended and the CPU enters the low power state until an interrupt occurs. Note: when the calculator is switched off, it is actually running a series of <code>halt</code>&rsquo;s while waiting for On to be pressed.</p>
<h2><a name="undoc"></a>Undocumented instructions</h2>
<p>The reason why these instructions were put into the hardware section is that although they were not documented for a long time, they worked because their existence comes from the structure of the inner circuitry of the Z80 processor. Most of these instructions were already listed in the previous sections, but it is useful to see them listed together.</p>
<h3>IXH/IXL/IYH/IYL instructions</h3>
<p>All the instructions that take advantage of these registers: <code>ld</code> and the 8-bit arithmetic and logical operations (<code>add</code>, <code>sub</code>, <code>xor</code> etc.); these special registers are officially supported in later CPU generations, but you have to be aware that the instructions accessing them are slower than the normal ones. Do not forget that you cannot use them with the <i>shifting</i>, the <code>res</code> and the <code>set</code> instructions!</p>
<h3>Dummy port accesses</h3>
<p>The <code>in (c)</code>/<code>in f,(c)</code> and <code>out (c),0</code> instructions.</p>
<h3>The SLL instruction</h3>
<p>It is important to mention again, that if you use <code>sll</code> in your code, your program will behave unexpectedly on the next generations of the Z80 (e. g. they are redefined in the Z380). Of course, it must work on all the TI calculators and on the ZX Spectrum as well.</p>
<h3>The autocopy instructions</h3>
<p>The instructions of this group were not yet mentioned. They are based on the shift/<code>set</code>/<code>res</code> instructions. What they do is besides modifying the contents of <tt>(ix/iy+n)</tt>, they copy the result into an 8-bit register (only into <tt>A</tt>, <tt>B</tt>, <tt>C</tt>, <tt>D</tt>, <tt>E</tt>, <tt>H</tt> or <tt>L</tt>). There exist various notations for these special instructions. If the base instruction was <code>ins&nbsp;ops</code> (<i>ins</i> is <code>sla</code>, <code>sra</code>, <code>sll</code>, <code>srl</code>, <code>rl</code>, <code>rr</code>, <code>rlc</code>, <code>rrc</code>, <code>set</code> or <code>res</code> and <i>ops</i> denotes its operands), the resulting instruction is: <code>ins reg8,ops</code>, <code>ins reg8=ops</code> or <code>ld reg8,ins ops</code> depending on which assembler you use. So for example you can use <code>srl b,(ix+$48)</code> (or <code>srl b=(ix+$48)</code> or <code>ld b,srl (ix+$48)</code>), which is <code>srl (ix+$48)</code> followed by <code>ld b,(ix+$48)</code>. Another example: <code>res d,5,(iy-$12)</code> which is <code>res 5,(iy-$12)</code> followed by <code>ld d,(iy-$12)</code>. The time needed to execute these instructions is exactly the same as if there was no autocopy! The only drawback is that you can only use them with <tt>(ix/iy+n)</tt>, as I mentioned above.</p>
<p><a href="app1.htm">Back to the index</a></p>
</body>
</html>
